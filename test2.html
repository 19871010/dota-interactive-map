<html>
<head>
</head>
<body>
Click to toggle cells, move to show FOV. Topology: <select id="topology">
<option value="4">4</option>
<option value="8" selected="selected">8</option>
</select><br/>
<canvas id="canvas" height="360" width="480"></canvas><br/>
FOV: <span id="fov"></span>ms, draw: <span id="draw"></span>ms, pos: <span id="pos"></span>
<script src="rot5.js"></script>
<script type="text/javascript">
var CELL = [12, 12];
var SIZE = [40, 30];
var COLOR_WALL = [150, 150, 150];
var COLOR_FLOOR = [255, 255, 255];
var COLOR_LIGHT = [180, 180, 180];

var CTX = document.querySelector("#canvas").getContext("2d");

CTX.canvas.width = CELL[0]*SIZE[0];
CTX.canvas.height = CELL[1]*SIZE[1];
CTX.fillStyle = "black";

var walls = {};
var lights = {};
var lightPassesCallback = function(x, y) {
    var key = x+","+y;
    return (!(key in walls));
}
    
var toggle = function(x, y, obstacleType, cx, cy, r) {
    var key = x+","+y;
    if (walls[key]) {
        delete walls[key];
    } else {
        walls[key] = [obstacleType, cx, cy, r];
    }
}
        
var redraw = function() {
    var t1 = Date.now();
    CTX.clearRect(0, 0, CTX.canvas.width, CTX.canvas.height);
    for (var x=0;x<SIZE[0];x++) {
      for (var y=0;y<SIZE[1];y++) {
        var key = x+","+y;
        var light = lights[key];
        var base = (walls[key] ? COLOR_WALL : COLOR_FLOOR);
        var c = [];
        for (var i=0;i<3;i++) {
          var factor = .9;
          if (light) { factor += COLOR_LIGHT[i]*1/255; }
          c[i] = Math.min(255, Math.round(base[i]*factor));
        }
        CTX.fillStyle = "rgb("+c.join(",")+")";
        CTX.fillRect(x*CELL[0], y*CELL[1], CELL[0], CELL[1]);
      }
    }
    var t2 = Date.now();
    document.querySelector("#draw").innerHTML = t2-t1;
}
    
var updateVisibility = function(x, y) {
    console.log('update');
    lights = {};
           
    var topology = parseInt(document.querySelector("#topology").value);            
    var fov = new ROT.FOV.PreciseShadowcasting(lightPassesCallback, {topology:topology});

    var t1 = Date.now();
    fov.walls = walls;
    fov.compute(x, y, 15, function(x, y, r, vis) {
        if (!walls[x+","+y]) lights[x+","+y] = vis;
    });

    var t2 = Date.now();
    document.querySelector("#fov").innerHTML = t2-t1;

    redraw();
}

var getCoords = function(e) {
    var x = e.clientX+document.body.scrollLeft - CTX.canvas.offsetLeft - CTX.canvas.clientLeft,
        y = e.clientY+document.body.scrollTop - CTX.canvas.offsetTop - CTX.canvas.clientTop,
        x2 = Math.floor(x/CELL[0]),
        y2 = Math.floor(y/CELL[1]);
    document.querySelector("#pos").innerHTML = x2+","+y2;
    return [x2, y2];
}    

CTX.canvas.addEventListener("click", function(e) {
    var coords = getCoords(e);
    toggle(coords[0], coords[1]);
    updateVisibility(coords[0], coords[1]);
});
var can = document.getElementById('canvas');
console.log(CTX.canvas);
CTX.canvas.addEventListener("mousemove", function(e) {
    console.log(e);
    var coords = getCoords(e);
    updateVisibility(coords[0], coords[1]);
});

/*for (var i=0;i<100;i++) {
    var x = Math.floor(ROT.RNG.getUniform()*SIZE[0]);
    var y = Math.floor(ROT.RNG.getUniform()*SIZE[1]);
    var obstacleType = Math.random() < 0.5 ? 'tree' : 'wall';
    generateObstacle(x, y, obstacleType);
}*/
/*
generateObstacle(10, 10, 'tree');
generateObstacle(12, 12, 'tree');
generateObstacle(15, 15, 'wall');
generateObstacle(16, 16, 'wall');
*/
generateObstacle(10, 12, 'tree');
generateObstacle(24, 10, 'tree');
generateObstacle(24, 12, 'tree');
generateObstacle(13, 24, 'tree');
generateObstacle(16, 23, 'tree');
generateObstacle(15, 25, 'tree');
generateObstacle(4, 4, 'tree');
generateObstacle(3, 16, 'tree');
generateObstacle(12, 10, 'tree');
//generateObstacle(16, 10, 'tree');
//generateObstacle(18, 12, 'tree');
//generateObstacle(20, 20, 'wall');
//generateObstacle(21, 21, 'wall');
function generateObstacle(x, y, obstacleType) {
    if (obstacleType == 'tree') {
        toggle(x, y, obstacleType, x+.5, y+.5, Math.SQRT2);
        toggle(x+1, y, obstacleType, x+.5, y+.5, Math.SQRT2);
        toggle(x+1, y+1, obstacleType, x+.5, y+.5, Math.SQRT2);
        toggle(x, y+1, obstacleType, x+.5, y+.5, Math.SQRT2);
        toggle(x+.5, y+.5, obstacleType, x+.5, y+.5, Math.SQRT2);
    }
    else {
        toggle(x, y, obstacleType, x, y, Math.SQRT2 / 2);
    }
}
redraw();    
var tests = [[9, 10], [9, 9], [23, 18], [19, 23], [30, 13], [24, 16], [13, 11], [12, 12], [10, 10], [11, 11], [12, 26], [2, 16], [13, 23]];
for(i = 0; i < tests.length; i++){
    (function(i){
        setTimeout(function(){
            updateVisibility(tests[i][0], tests[i][1]);
            console.log('updateVisibility', tests[i][0], tests[i][1]);
        }, 1000 * i);
    }(i));
}
//updateVisibility(23, 18);
//updateVisibility(19, 23);
//updateVisibility(30, 13);
//updateVisibility(24, 16);
//updateVisibility(13, 11);
//updateVisibility(13, 11);
//updateVisibility(9, 9);

//updateVisibility(12, 12);
//updateVisibility(10, 10);
//updateVisibility(11, 11);
//updateVisibility(12, 26);
//updateVisibility(2, 16);
//updateVisibility(13, 23);
//updateVisibility(9, 10);
//updateVisibility(9, 9);
//console.log(isBefore(0.8568876132829688, 0.052515144070253095))
//console.log(isBefore(-0.007659469872049726, -0.15584509773091626))
console.log(isBetween(0, -0.052515144070253095, 1.5182811827246434))
//console.log(isBetween(0.8568876132829688, 0.052515144070253095, 1.5182811827246434))
/*console.log(isBetween(0, 1.7266414245258128,0.15246306597385323))
console.log(isBetween(0.26631491134078966, -0.38590036537208394,0.7806914850718455))
console.log(isBetween(-0.5439657725417493, -0.771450120270696,1.4149512290639803))
console.log(isBetween(-2.986454242896597, 1,0))
console.log(diff(2.9751669120424067,-2.188773445398278))
console.log(diff(-1.0380784185395269,-1.1801892830972098))
console.log(isBefore(-1.0380784185395269,-1.1801892830972098))
*/
</script>
</body>
</html>